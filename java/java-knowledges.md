## 자바 기초적인 지식들을 내 말로 다시 표현해보기

### 용어
- **변수**: 데이터를 저장할 수 있는 메모리 공간인데 이름이 붙음.
- **타입**: 변수에 어떤 형식의 데이터를 담을 수 있는지 나타내는 역할.
- **메서드**: 특정 값을 넘겨받아 결과를 반환하는 것.
- **매개변수**: 메서드 혹은 생성자에 값을 전달하기 위해 사용되는 변수를 의미한다. ex) `String name`
    - **인자(Argument)**: 실제 메서드를 **호출할때 전달하는 값을 의미한다. ex) `“Seokho”`
- **클래스**: 자바에서 가장 작은 단위며 객**체를 만드는데 사용이 된다.
    - 필드(클래스가 가지는 상태)
    - 메서드(클래스가 가지는 행위)
- **컴파일**: 고수준 언어로 작성된 코드를 컴퓨터에서 실행시킬 수 있는 저수준 언어로 변환하는 작업

### **Java에서의 컴파일 과정**

1. 소스코드를 `javac` 컴파일러가 .class 파일(바이트코드)로 변환시켜 디스크에 저장한다.
    - 여기서의 컴파일은 jvm에서 실행할 수 있는 코드로 변경되는것이라서 흔히 말하는 컴파일과는 조금 다르게 봐야할까?
2. 바이트코드를 jvm에서 실행하는데 이때 JIT 컴파일러가 컴파일을 해서 실행하게 된다.
- 진입점이 되는 클래스의 실행을 위해서는 main 메서드가 필수적으로 존재해야한다.
    - `String[] args` : 외부에서 해당 애플리케이션의 동작을 설정할 수 있도록 하기 위해 이런 형식을 사용한다. 대표적으로 SpringBoot 실행 시에 옵션을 주는 행위도 args를 통해 전달되서 내부적으로 세팅한다.

### **Array / ArrayList /  LinkedList의 차이**

**공통점**

- 모두 여러개의 데이터를 순차적으로 저장할 수 있다.

**Array**

- 최초 설정한 사이즈를 변경할 수 없다. ex) int[32] → 32개의 데이터밖에 넣지 못한다.
- 데이터가 연속된 메모리 공간에 저장되기 때문에 접근 속도가 빠르다.

**ArrayList**

- 내부적으로는 Array로 구현이 되어 있다. 최초 사이즈를 넘어가면 x1.5로 사이즈를 늘려간다.
- 데이터를 삽입하거나 삭제하게 되면 앞 혹은 뒤에 있는 데이터를 한칸씩 옮기게 된다.
- 기본 타입은 저장이 안된다.

**LinkedList**

- 내부적으로 이중 LinkedList로 구현되어 있다.
- 데이터를 삽입할때는 prev, next가 가리키는 노드를 변경해주면 된다. O(1)
- 조회 시에는 데이터를 인덱스로 접근하는게 힘들기 때문에 ArrayList보다 오래걸린다. O(n)

### 생명주기

**생성자** : 객체를 생성할때 사용되는 메서드.

- 기본 생성자 : 클래스 내에 다른 생성자가 존재하지 않을 경우 클래스를 컴파일하게 되면 javac에 의해서 자동으로 생성됨.

**변수**

- 지역 변수: 중괄호 내에서 선언된 변수
- 매개 변수: 메서드에 전달되는 변수
- 인스턴스 변수: 클래스 내부에 선언된 변수 (정적 변수는 포함되지 않는다)
    - 기본타입의 경우 초기화를 하지 않으면 기본값이 설정된다.
- 클래스 변수: 정적 선언된 변수
    - 기본타입의 경우 초기화를 하지 않으면 기본값이 설정된다.

**타입**

- 기본 타입: 자바 컴파일러 수준에서 이미 정해둔 타입들이며 개발자가 추가할 수 없다.
- 참조 타입

**매개변수의 생명주기**

- 메서드 호출 시 JVM runtime area에 해당 스레드의 스택 프레임이 생성된다.
- 스택 프레임에 해당 매개변수가 생성되고 전달된 인자가 복사됨.
    - 이때 기본타입이면 값 복사, 참조타입이면 주소가 복사됨.
- 메서드 종료 시 스택 프레임과 함께 메모리에서 제거됨.

**인스턴스 변수의 생명주기**

- JVM의 runtime area 하위 힙에 객체가 생성될 때 저장되고 객체가 더이상 참조되지 않을때 제거됨.

**클래스 변수의 생명주기**

- 클래스가 최초 로드 될때 runtime area 하위 메서드영역에 생성된다.
- 클래스가 언로드 되거나 jvm 종료 시 제거된다.

### **Java의 call by value, call by reference**

- 자바에서는 call by value 밖에 존재하지 않음.
    - call by value: 값을 복사해서 전달하는 방식으로 원본 값에는 영향을 주지 않는 방식.
- 참조형 데이터를 전달할때는 주소를 복사하는 방식으로 동작한다.
    - 물론 해당 참조형 데이터 내부의 값을 수정하면 원본에도 영향이 간다.

### **JVM의 Runtime Area**

- Method Area
- Heap
- VM Stack
    - 해당 영역에 스레드별로 스택을 만들어서 push, pop 한다.
    - 여기에 재귀 같은 방식으로 메서드가 지속적으로 호출되다가 VM의 stack의 최대 크기를 넘어설 경우 StackOverflow 예외가 발생하는것이다.
    - 아예 스택 프레임을 생성할 메모리 공간 자체가 부족하면 OutOfMemory 예외가 발생한다.
- Native Method Stack
- Program Counter Register

### **byte의  최소값**

- 비트로 표현할때 맨 앞자리는 부호를 의미하기도 한다. (0 = 양수, 1 = 음수)
    - 0111111 → 127 / 1000000 → -128
- 자바에서는 byte의 최소값에 -1을 하면 `10000000 - 00000001` 로 계산이 되어 결과적으로는 127이 된다.

### **float와 double의 부동소수점 이슈**

- 자바는 부동 소수점 방식으로 소수를 표현함 (지수 & 가수로 구분해서 표현)
- 특정 값들은 무한 반복 소수여서 정확하게 표현을 못하고 비트 수에 가장 가까운 근사치가 저장이 된다.
    - ex) float의 경우 가수를 23자리까지밖에 저장을 못해서 가장 가까운 23비트 이진수로 잘라서 저장함.

**타입 캐스팅**

- 큰 범위 → 작은 범위로 가면 앞의 비트를 모두 버리는 방식으로 동작한다.
  이로 인해 예상치 못한 결과가 나올 수 있음.

### **Java의 모니터락**
*(이건 실제 Monitor 클래스의 코드를 확인해봐야할듯)*

- 모든 객체는 내부적으로 모니터(모니터락)이라는걸 가지고 있다. 이 모니터락의 용도는 동시성을 제어하기 위함.
- synchronized 키워드가 붙은 메서드를 호출하게 되면 해당 인스턴스의 모니터락을 획득해야함.

### **배열은 메모리 상으로도 연속된 주소를 할당받을까?**

Yes.
int배열 같은 경우 하나의 데이터가 4byte니까 `길이 * 4` 만큼 공간을 확보한다.
그리고 실제 데이터에 접근할때도 JVM은 `배열 시작 주소 + (배열 길이 * 4)` 와 같은 방식으로 계산해서 접근한다.
